<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VST 3 Interfaces: VST 3 API Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxysmtg.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>VST 3 API Documentation </h1><h3 class="version">VST 3.6.5 </h3><div align="center">
<img src="vst3_logo_mid.jpg" alt="vst3_logo_mid.jpg"/>
</div>
<p>The VST 3 API is an interface collection designed for realtime audio processing components. Such a component can be an audio effect or an audio instrument.</p>
<p>VST 3 is based on a technology called VST Module Architecture. Please have a look at the <a href="../base/index.html">VST-MA documentation</a> to find out more about how the Plug-in system works in general.</p>
<p>The API files belonging to VST 3 are located in folder <a href="../../pluginterfaces/vst" target="_blank">pluginterfaces/vst</a> <br/>
 <br/>
</p>
<h2><a class="anchor" id="vst3Contents">
Contents</a></h2>
<dl class="user"><dt><b>Basics</b></dt><dd><ul>
<li><a class="el" href="index.html#vst3Structure">Basic Conception</a></li>
<li><a class="el" href="index.html#vst3Processing">The Processing Part</a></li>
<li><a class="el" href="index.html#vst3Editing">The Editing Part</a></li>
<li><a class="el" href="index.html#vst3Communication">Communication between the components</a></li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Details</b></dt><dd><ul>
<li><a class="el" href="vst3Automation.html">Parameters and Automation</a></li>
<li><a class="el" href="vst3Units.html">Units</a></li>
<li><a class="el" href="vst3Presets.html">Presets &amp; Program Lists</a></li>
<li><a class="el" href="vst3Multitimbral.html">Complex Plug-in Structures / Multi-timbral Instruments</a></li>
<li><a class="el" href="vst3loc.html">VST 3 Locations</a></li>
<li><a class="el" href="workflow.html">Workflow Diagram</a> <br/>
<br/>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>New in VST 3.5</b></dt><dd><ul>
<li><a class="el" href="noteExpression.html">Note Expression Support</a></li>
<li><a class="el" href="keyswitch.html">Key Switch Support</a></li>
<li><a class="el" href="representation.html">Remote Representation of Parameters Support</a></li>
<li><a class="el" href="contextmenu.html">Context Menu Support</a></li>
</ul>
</dd></dl>
<p><br/>
 <br/>
</p>
<h2><a class="anchor" id="vst3Structure">
Basic Conception</a></h2>
<p>A VST 3 audio effect or instrument basically consists of two parts: a processing part and an edit controller part. <br/>
 The corresponding interfaces are:</p>
<ul>
<li>Processor : <a class="el" href="classSteinberg_1_1Vst_1_1IAudioProcessor.html" title="Audio Processing Interface.">Steinberg::Vst::IAudioProcessor</a> + <a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html" title="Component Base Interface.">Steinberg::Vst::IComponent</a></li>
<li>Controller : <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html" title="Edit controller component interface.">Steinberg::Vst::IEditController</a></li>
</ul>
<div align="center">
<img src="basic_structure.jpg" alt="basic_structure.jpg"/>
</div>
<p>The design of VST 3 suggests a complete separation of processor and edit controller by implementing two components. Splitting up an effect into these two parts requires some extra efforts for an implementation of course. <br/>
 But this separation enables the host to run each component in a different context. It can even run them on different computers. Another benefit is that parameter changes can be separated when it comes to automation. While for processing these changes need to be transmitted in a sample accurate way, the GUI part can be updated with a much lower frequency and it can be shifted by the amount that results from any delay compensation or other processing offset. <br/>
 <br/>
 A Plug-in that supports this separation has to set the <a class="el" href="namespaceSteinberg_1_1Vst.html#a626a070dcd2e025250f41b9c3f9817cda3185111648c1599241528f1a7f523396" title="Component can be run on remote computer.">Steinberg::Vst::kDistributable</a> flag in the class info of the processor component (<a class="elRef" doxygen="base.tag:../base/" href="../base/structSteinberg_1_1PClassInfo2.html#ab5ab9135185421caad5ad8ae1d758409">Steinberg::PClassInfo2::classFlags</a>). Of course not every Plug-in can support this, for example if it depends deeply on resources that can not be easily moved to another computer. So when this flag is not set, the host must not try to separate the components in any way.<br/>
 Although it is not recommended, it is possible to implement both, the processing part and the controller part in one component class. The host tries to query the <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html" title="Edit controller component interface.">Steinberg::Vst::IEditController</a> interface after creating an <a class="el" href="classSteinberg_1_1Vst_1_1IAudioProcessor.html" title="Audio Processing Interface.">Steinberg::Vst::IAudioProcessor</a> and on success uses it as controller. <br/>
 <br/>
 </p>
<dl class="note"><dt><b>Note:</b></dt><dd>A host does not need to instantiate the Controller part of a Plug-in for processing it. The Plug-in should be prepared for processing without having the controller part instantiated. <br/>
</dd></dl>
<h3><a class="anchor" id="Initialize">
Initialize</a></h3>
<p>Both <a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html" title="Component Base Interface.">Steinberg::Vst::IComponent</a> and <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html" title="Edit controller component interface.">Steinberg::Vst::IEditController</a> derive from <a class="elRef" doxygen="base.tag:../base/" href="../base/classSteinberg_1_1IPluginBase.html">Steinberg::IPluginBase</a>. The purpose of this basic interface is to initialize the component and to terminate it before it is destroyed. <br/>
 <br/>
 The context parameter passed to <a class="elRef" doxygen="base.tag:../base/" href="../base/classSteinberg_1_1IPluginBase.html#a74e46aa2a4c6c7254564c83675a4c514">Steinberg::IPluginBase::initialize</a> is <a class="el" href="classSteinberg_1_1Vst_1_1IHostApplication.html" title="Basic Host Callback Interface.">Steinberg::Vst::IHostApplication</a>. Hosts should not call others functions before initialize is called!, except <a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a4618e7358890d549f990010bea4a4137" title="Called before &#39;initialize&#39; to set the component usage (optional).">Steinberg::Vst::IComponent::setIoMode</a> which need to be called before or <a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a8aa65685068ad033af57b1497926b689" title="Called before initializing the component to get information about the controller...">Steinberg::Vst::IComponent::getControllerClassId</a> which could be called before. <br/>
 <br/>
</p>
<h3><a class="anchor" id="creation">
Creation and Initialize from Host point of view</a></h3>
<p>Here an example of host implementation creating the component and its associated controller of a Plug-in with a given classID: <br/>
</p>
<div class="fragment"><pre class="fragment">   <span class="comment">//------------------------------------------------------------------------</span>
   ...
   Vst::IComponent* processorComponent;
   Vst::IEditController* editController;
   IPluginFactory* factory;
   ...
   <span class="comment">// factory already initialized (after the library is loaded, see validator for example)</span>
   ...
   <span class="comment">// create its component part</span>
   <a class="codeRef" doxygen="base.tag:../base/" href="../base/namespaceSteinberg.html#a902761e005a6252e538c766de48fc957">tresult</a> result = factory-&gt;createInstance (classID, Vst::IComponent::iid, (<span class="keywordtype">void</span>**)&amp;processorComponent);
   <span class="keywordflow">if</span> (processorComponent &amp;&amp; (result == kResultOk))
   {
      <span class="comment">// initialize the component with our host context (note: initialize called just after creatInstance)</span>
      res = (processorComponent-&gt;initialize (gStandardPluginContext) == <a class="codeRef" doxygen="base.tag:../base/" href="../base/namespaceSteinberg.html#a06fc87d81c62e9abb8790b6e5713c55ba941549edbe23d0f21851403ae03ad4df">kResultOk</a>);

      <span class="comment">// try to create the controller part from the component </span>
      <span class="comment">// for Plug-ins which did not succeed to separate component from controller :-(</span>
      <span class="keywordflow">if</span> (processorComponent-&gt;queryInterface (Vst::IEditController::iid, (<span class="keywordtype">void</span>**)&amp;editController) != <a class="codeRef" doxygen="base.tag:../base/" href="../base/namespaceSteinberg.html#a06fc87d81c62e9abb8790b6e5713c55ba9e60fad4624bee040985edebe1800372">kResultTrue</a>)
      {
         FUID controllerCID;

         <span class="comment">// ask for the associated controller class ID (could be called before processorComponent-&gt;initialize ())</span>
         <span class="keywordflow">if</span> (processorComponent-&gt;getControllerClassId (controllerCID) == <a class="codeRef" doxygen="base.tag:../base/" href="../base/namespaceSteinberg.html#a06fc87d81c62e9abb8790b6e5713c55ba9e60fad4624bee040985edebe1800372">kResultTrue</a> &amp;&amp; controllerCID.isValid ())
         {     
            <span class="comment">// create its controller part created from the factory</span>
            result = factory-&gt;createInstance (controllerCID, Vst::IEditController::iid, (<span class="keywordtype">void</span>**)&amp;editController);
            <span class="keywordflow">if</span> (editController &amp;&amp; (result == kResultOk))
            {
               <span class="comment">// initialize the component with our context</span>
               res = (editController-&gt;initialize (gStandardPluginContext) == <a class="codeRef" doxygen="base.tag:../base/" href="../base/namespaceSteinberg.html#a06fc87d81c62e9abb8790b6e5713c55ba941549edbe23d0f21851403ae03ad4df">kResultOk</a>);
               
               <span class="comment">// now processorComponent and editController are initialized... :-)</span>
            }
         }
      }
   }
   <span class="comment">//------------------------------------------------------------------------</span>
</pre></div><p> <br/>
 <br/>
</p>
<h3><a class="anchor" id="Extensions">
Extensions</a></h3>
<p>The functionality of the components implementing these basic interfaces can be extended by a number of optional interfaces, that only need to be implemented if this extension is required. <br/>
 <br/>
</p>
<ul>
<li>Processor Extensions:<ul>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IConnectionPoint.html" title="Connect a component with another one.">Steinberg::Vst::IConnectionPoint</a></li>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IUnitData.html" title="Component extension to access unit data.">Steinberg::Vst::IUnitData</a></li>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IProgramListData.html" title="Component extension to access program list data.">Steinberg::Vst::IProgramListData</a></li>
</ul>
<br/>
</li>
<li>Edit Controller Extensions:<ul>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IConnectionPoint.html" title="Connect a component with another one.">Steinberg::Vst::IConnectionPoint</a></li>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IMidiMapping.html" title="MIDI Mapping Interface.">Steinberg::Vst::IMidiMapping</a></li>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IUnitInfo.html" title="Edit controller extension to describe the Plug-in structure.">Steinberg::Vst::IUnitInfo</a> <br/>
 <br/>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="Persistence">
Persistence</a></h3>
<p>The host stores and restores the complete state of the processor and of the controller in project files and in preset files:</p>
<ul>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a10db03106be8ba89d23859fa6be5d9f6" title="Retrieves complete state of component.">Steinberg::Vst::IComponent::getState</a> + <a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a77ac39bcc5c4b15818b1a87de2573805" title="Sets complete state of component.">Steinberg::Vst::IComponent::setState</a> <br/>
 stores and restores the DSP model</li>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#a10db03106be8ba89d23859fa6be5d9f6" title="Gets the controller state.">Steinberg::Vst::IEditController::getState</a> + <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#a77ac39bcc5c4b15818b1a87de2573805" title="Sets the controller state.">Steinberg::Vst::IEditController::setState</a> <br/>
 stores and restores any GUI settings that are not related to the processor (like scroll positions etc)</li>
<li><b>Restore:</b> When the states are restored, the host passes the processor state to both the processor and the controller (<a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#a4c2e1cafd88143fda2767a9c7ba5d48f" title="Receives the component state.">Steinberg::Vst::IEditController::setComponentState</a>). A host must always pass that state to the processor first. The controller then has to synchronize its parameters to this state (but must not perform any IComponentHandler callbacks). <br/>
 After restoring a state, the host will rescan the parameters (asking the controller) in order to update its intern representation.<br/>
 See also <a class="elRef" doxygen="base.tag:../base/" href="../base/classSteinberg_1_1IBStream.html">Steinberg::IBStream</a> <br/>
 <br/>
</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><ul>
<li><a class="el" href="group__vstIPlug.html">VST 3 Interfaces to be implemented by Plug-in</a></li>
<li><a class="el" href="group__vstIHost.html">VST 3 Interfaces to be implemented by Host</a></li>
</ul>
</dd></dl>
<p><br/>
 Back to <b><a class="el" href="index.html#vst3Contents">Contents</a></b> <br/>
 <br/>
</p>
<h2><a class="anchor" id="vst3Processing">
The Processing Part</a></h2>
<div align="center">
<img src="processor.jpg" alt="processor.jpg"/>
</div>
<p>The processing part consists of two related interfaces. The reason for the split-up is the idea to use the basic interfaces Vst::IComponent not only for audio Plug-ins but also for other kinds of media as well (e.g. video processing in the future). Hence the Vst::IAudioProcessor interface represents the audio specific part of a processing component. Let's have a closer look at the concepts. <br/>
 <br/>
</p>
<h3><a class="anchor" id="icomponent">
Steinberg::Vst::IComponent</a></h3>
<p>Steinberg::Vst::IComponent:</p>
<ol type="1">
<li><b>Edit controller association</b>: In order to enable the host to create a corresponding edit controller the processing component has to provide the matching class-ID. The host uses the module's class factory to create the controller component. (<a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a8aa65685068ad033af57b1497926b689" title="Called before initializing the component to get information about the controller...">Steinberg::Vst::IComponent::getControllerClassId</a>) <br/>
 <br/>
</li>
<li><a class="el" href="structSteinberg_1_1Vst_1_1BusInfo.html" title="Bus Description.">Steinberg::Vst::BusInfo</a> - <a class="elRef" doxygen="vstsdk.tag:../vstsdk/" href="../vstsdk/classSteinberg_1_1Vst_1_1Bus.html">Bus</a> Description. A bus can be understood as a 'collection of data channels' belonging together. It describes a data input or a data output of the Plug-in. A VST component can define any desired number of buses, but this number must <b>never</b> change. Dynamic usage of buses is handled in the host by activating and deactivating buses. The component has to define the maximum number of supported buses and it has to define which of them are active by default. A host that can handle multiple buses, allows the user to activate buses that were initially inactive.See also: <a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a41b0e971a0ff153a4eb34274750b0c91" title="Called after the Plug-in is initialized.">IComponent::getBusInfo</a> , <a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a3ab7d06aaefe03da1fcd1819f1261050" title="Called upon (de-)activating a bus in the host application.">IComponent::activateBus</a>  <br/>
 <br/>
</li>
<li>Routing Information. When the Plug-in supports multiple I/O buses, a host may want to know how the buses are related. The relation of an event-input-channel to an audio-output-bus in particular is of interest to the host (in order to relate MIDI-tracks to audio-channels) <br/>
 See also: <a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#aa0ffeccad3c44364a199ce56365a4c12" title="Retrieves routing information (to be implemented when more than one regular input...">IComponent::getRoutingInfo</a>, <a class="el" href="vst3Multitimbral.html#vst3Routing">Routing</a>  <br/>
 <br/>
</li>
</ol>
<h3><a class="anchor" id="iaudioprocessor">
Steinberg::Vst::IAudioProcessor</a></h3>
<p>Steinberg::Vst::IAudioProcessor:</p>
<ol type="1">
<li><b>Setup:</b> The processor must be configured before processing can start. Configurations are only allowed when the processor is inactive (<a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a0a840e8077eb74ec429b8007c7b83517" title="Activates / deactivates the component.">Steinberg::Vst::IComponent::setActive</a>). <br/>
 <br/>
<ul>
<li><b>Process setup</b>: The processor is informed about the parameters that can not be changed while processing is active. (<a class="el" href="structSteinberg_1_1Vst_1_1ProcessSetup.html" title="Audio processing setup.">Steinberg::Vst::ProcessSetup</a>). <br/>
 <br/>
</li>
<li><b>Dynamic Speaker Arrangements</b>: The host can try to change the number of channels of an audio bus. By default the speaker arrangement is defined by the Plug-in. In order to adjust the Plug-in to a context where a different speaker arrangement is used, the host can try to change it. (<a class="el" href="classSteinberg_1_1Vst_1_1IAudioProcessor.html#ad3bc7bac3fd3b194122669be2a1ecc42" title="Try to set (from host) a predefined arrangement for inputs and outputs.">Steinberg::Vst::IAudioProcessor::setBusArrangements</a>)</li>
</ul>
<br/>
 When the processor has been configured, it has to be activated. The activation call signals that all configurations have been finished. In addition to that, the processor has got a 'processing state'. Before a host actually begins to perform processing calls, it has to signal this by calling IAudioProcessor::setProcessing(true). When the host will perform processing no longer, it must call IAudioProcessor::setProcessing(false) after the last processing call. Please see also: <a class="el" href="workflow.html">Workflow Diagram</a> <br/>
 <br/>
</li>
<li><b>Process:</b> <a class="el" href="classSteinberg_1_1Vst_1_1IAudioProcessor.html#a6b98eb31cf38ba96a28b303c13c64e13" title="The Process call, where all information (parameter changes, event, audio buffer)...">Steinberg::Vst::IAudioProcessor::process</a> is the method that implements the actual processing. Any data needed for processing is passed to it as parameter <a class="el" href="structSteinberg_1_1Vst_1_1ProcessData.html" title="Any data needed in audio processing.">Steinberg::Vst::ProcessData</a>. This is necessary because processing often is performed in a separate thread and this is a simple way to avoid thread synchronization problems. <br/>
 <br/>
<ul>
<li><b>Block Size</b>: Processing is done in blocks. The maximum number of samples to be processed in one block is set in <a class="el" href="classSteinberg_1_1Vst_1_1IAudioProcessor.html#aefb5731b94dbc899a4a7e9cd1c96e6a2" title="Called in disable state (not active) before processing will begin.">Steinberg::Vst::IAudioProcessor::setupProcessing</a>. The actual number of samples in a processing block is transmitted in the process call and can be different from call to call, but it must be a value between 1 and maxSamplesPerBlock. <br/>
 <br/>
</li>
<li><b>Audio Buffers</b>: For any audio bus defined by the Plug-in the host must provide buffer data - even for inactive buses. Buses are addressed by index, so leaving out inactive buses will mix-up these indices. The actual data buffer can be null though. (see <a class="el" href="structSteinberg_1_1Vst_1_1AudioBusBuffers.html">Steinberg::Vst::AudioBusBuffers</a>).<br/>
 Note that channelBuffers32 (or channelBuffers64) buffers pointers could be the same or different for input and output: this has to be take into account in the process function (for example not reseting the output before processing if input and output buffers are the same!). It could be the same for multiple inputs or multiple outputs (case of instrument Plug-ins) all outputs (or inputs) could share the same buffer!<br/>
 <b>Important</b> : the host could call <a class="el" href="classSteinberg_1_1Vst_1_1IAudioProcessor.html#a6b98eb31cf38ba96a28b303c13c64e13" title="The Process call, where all information (parameter changes, event, audio buffer)...">Steinberg::Vst::IAudioProcessor::process</a> without buffers (numInputs and numOutputs of <a class="el" href="structSteinberg_1_1Vst_1_1AudioBusBuffers.html" title="Processing buffers of an audio bus.">Steinberg::Vst::AudioBusBuffers</a> are zeroed, numSamples too), in order to flush parameters (from host to Plug-in). Parameters flush could happen only when the host needs to send parameter changes and no processing is called. <br/>
 <br/>
</li>
<li><b>Parameters &amp; Automation</b>: Any parameter changes are transmitted in the process call through the interfaces <a class="el" href="classSteinberg_1_1Vst_1_1IParameterChanges.html" title="All parameter changes of a processing block.">Steinberg::Vst::IParameterChanges</a> and <a class="el" href="classSteinberg_1_1Vst_1_1IParamValueQueue.html" title="Queue of changes for a specific parameter.">Steinberg::Vst::IParamValueQueue</a>. Simple parameter changes as result of GUI interaction are transmitted exactly in the same way as automation. (see <a class="el" href="vst3Automation.html">Parameters and Automation</a>). <br/>
 <br/>
</li>
<li><b>Context</b>: For each processing block the host should provide information about its state. <br/>
 See <a class="el" href="structSteinberg_1_1Vst_1_1ProcessContext.html">Steinberg::Vst::ProcessContext</a> <br/>
 <br/>
</li>
<li><b>Events</b>: <a class="el" href="classSteinberg_1_1Vst_1_1IEventList.html" title="List of events to process.">Steinberg::Vst::IEventList</a></li>
</ul>
</li>
</ol>
<p><br/>
 Back to <b><a class="el" href="index.html#vst3Contents">Contents</a></b> <br/>
 <br/>
</p>
<h2><a class="anchor" id="vst3Editing">
The Editing Part</a></h2>
<div align="center">
<img src="edit controller.jpg" alt="edit controller.jpg"/>
</div>
<p>The edit controller is responsible for the GUI aspects of the Plug-in. Its standard interface is <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html" title="Edit controller component interface.">Steinberg::Vst::IEditController</a>. The host has to provide a callback interface for the edit controller named <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html" title="Host callback interface for an edit controller.">Steinberg::Vst::IComponentHandler</a>. The handler is essential for the communication with both the host and the processor.</p>
<ul>
<li><b>GUI:</b> The controller optionally can define an editor view. The method <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#a1fa4ed10cc0979e5559045104c998b1a" title="Creates the editor view of the Plug-in, currently only &quot;editor&quot; is supported...">Steinberg::Vst::IEditController::createView</a> allows the host to specify the type of the view by passing an id-string. Currently the only type defined is "editor" (<a class="el" href="namespaceSteinberg_1_1Vst_1_1ViewType.html#aaa62c4c32f0270a908eb20c7c7124dfc">Steinberg::Vst::ViewType::kEditor</a>), but there might be variations in future versions (eg. "setup"). <br/>
 See also <a class="elRef" doxygen="base.tag:../base/" href="../base/classSteinberg_1_1IPlugView.html">Steinberg::IPlugView</a> <br/>
 <br/>
</li>
<li><b>Parameters:</b> The controller is responsible for the management of parameters. Any change to a parameter that is caused by user interaction in the Plug-in GUI must be properly reported to the <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html" title="Host callback interface for an edit controller.">Steinberg::Vst::IComponentHandler</a>. The host is responsible for transmitting the change to the processor. In order to make recording of automation work accordingly it is necessary to call <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#a8456ad739430267a12dda11a53fe9223">beginEdit</a>, <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#a135d4e76355ef0ba0a4162a0546d5f93">performEdit</a> and <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#ae380206486b11f000cad7c0d9b6e877c">endEdit</a> in the expected order! <br/>
 With the new interface <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler2.html">IComponentHandler2</a> (since VST 3.1), the Plug-in (from UI) could group parameters which should use the same timestamp in host when writing automation, by wrapping a set of beginEdit/performEdit/endEdit functions (see <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html">IComponentHandler</a>) with <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler2.html#aba339113df404a6b3c557774d4aa9102">startGroupEdit</a> and <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler2.html#adbdc10ff7ecd96fa365ad4f98d57b55e">finishGroupEdit</a>. <br/>
 More details can be found on the page about <a class="el" href="vst3Automation.html#vst3ParameterIntro">Parameters</a>. <br/>
 <br/>
</li>
<li><b> Plug-in structure:</b> If the Plug-in is composed of discrete functional parts, the edit controller should publish this structure and the parameters belonging to each part by implementing the <a class="el" href="classSteinberg_1_1Vst_1_1IUnitInfo.html" title="Edit controller extension to describe the Plug-in structure.">Steinberg::Vst::IUnitInfo</a> interface. More details can be found on the page about <a class="el" href="vst3Units.html">Units</a>.</li>
</ul>
<p><br/>
 Back to <b><a class="el" href="index.html#vst3Contents">Contents</a></b> <br/>
 <br/>
</p>
<h2><a class="anchor" id="vst3Communication">
Communication between the components</a></h2>
<p>The two VST 3 components (processor and controller) need a way to communicate. It is the task of the host to handle this. <br/>
 <br/>
</p>
<h3><a class="anchor" id="standard">
Standard Communication</a></h3>
<p>All standard data (like parameter changes) are transmitted between processor and controller using the basic interfaces listed above.</p>
<ul>
<li>After creation of processor and controller the host will set the controller component state from the processors state. [This has changed from the previous SDK, where it was assumed that after creation the controller and the processor are in sync] <br/>
</li>
<li>When the host sets a new processor state (<a class="el" href="classSteinberg_1_1Vst_1_1IComponent.html#a77ac39bcc5c4b15818b1a87de2573805" title="Sets complete state of component.">Steinberg::Vst::IComponent::setState</a>) this state is always transmitted to the controller as well (<a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#a4c2e1cafd88143fda2767a9c7ba5d48f" title="Receives the component state.">Steinberg::Vst::IEditController::setComponentState</a>). The controller then has to synchronize to this state and adjust its parameters. <br/>
</li>
<li>When the controller transmits a parameter change to the host, the host synchronizes the processor by passing the new values as <a class="el" href="classSteinberg_1_1Vst_1_1IParameterChanges.html" title="All parameter changes of a processing block.">Steinberg::Vst::IParameterChanges</a> to the process call. <br/>
</li>
<li>The processor can transmit outgoing parameter changes to the host as well (<a class="el" href="structSteinberg_1_1Vst_1_1ProcessData.html#af08c4f7dfd9e456cc98ba0eb325993ae" title="outgoing parameter changes for this block (optional)">Steinberg::Vst::ProcessData::outputParameterChanges</a>). These are transmitted to the edit controller by the call of <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#aded549c5b0f342a23dee18cc41ece6b8" title="Sets the normalized value to the parameter associated to the paramID.">Steinberg::Vst::IEditController::setParamNormalized</a>. <br/>
</li>
</ul>
<div align="center">
<img src="standard_communication.jpg" alt="standard_communication.jpg"/>
</div>
<p> <br/>
 <br/>
</p>
<h3><a class="anchor" id="private">
Private Communication</a></h3>
<p>Data that is unknown to the host can be transmitted by the means of messages. The communication interfaces are</p>
<ul>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IConnectionPoint.html" title="Connect a component with another one.">Steinberg::Vst::IConnectionPoint</a> : The host establishes a connection between processor and controller</li>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IMessage.html" title="Private Plug-in message.">Steinberg::Vst::IMessage</a> : Represents a message to send to the counterpart</li>
<li><a class="el" href="classSteinberg_1_1Vst_1_1IAttributeList.html" title="Attribute list used in IMessage and IStreamAttributes.">Steinberg::Vst::IAttributeList</a> : A list of attributes belonging to a message</li>
</ul>
<p><br/>
 Please note that messages from the processor to the controller must not be sent during the process call! This sending could be not speed enough and then break the real time processing. Such tasks should be handled in a separate timer thread.</p>
<div align="center">
<img src="component_communication.jpg" alt="component_communication.jpg"/>
</div>
<p> <br/>
 <br/>
</p>
<h3><a class="anchor" id="initialization">
Initialization of communication from Host point of view</a></h3>
<p>Here an example of host implementation where the component and controller parts are connected and synchronized:</p>
<div class="fragment"><pre class="fragment">   ...
   <span class="comment">// the component and the controller parts are previously be created and initialized (see above)</span>
   ...
   <span class="keywordflow">if</span> (editController)
   {
      <span class="comment">// set the host handler</span>
      <span class="comment">// the host set its handler to the controller</span>
      editController-&gt;setComponentHandler (myHostComponentHandler);

      <span class="comment">// connect the 2 components</span>
      Vst::IConnectionPoint* iConnectionPointComponent = 0;
      Vst::IConnectionPoint* iConnectionPointController = 0;

      processorComponent-&gt;queryInterface (Vst::IConnectionPoint::iid, (<span class="keywordtype">void</span>**)&amp;iConnectionPointComponent);
      editController-&gt;queryInterface (Vst::IConnectionPoint::iid, (<span class="keywordtype">void</span>**)&amp;iConnectionPointController);

      <span class="keywordflow">if</span> (iConnectionPointComponent &amp;&amp; iConnectionPointController)
      {
         iConnectionPointComponent-&gt;connect (iConnectionPointController);
         iConnectionPointController-&gt;connect (iConnectionPointComponent);
      }

      <span class="comment">// synchronize controller to component by using setComponentState</span>
      MemoryStream stream; <span class="comment">// defined in &quot;public.sdk/source/common/memorystream.h&quot;</span>
      stream.setByteOrder (kLittleEndian);
      <span class="keywordflow">if</span> (processorComponent-&gt;getState (&amp;stream) == <a class="codeRef" doxygen="base.tag:../base/" href="../base/namespaceSteinberg.html#a06fc87d81c62e9abb8790b6e5713c55ba9e60fad4624bee040985edebe1800372">kResultTrue</a>)
      {
         stream.rewind ();
         editController-&gt;setComponentState (&amp;stream);
      }

      <span class="comment">// now processorComponent and editController parts are connected and synchronized...:-)</span>
   }
</pre></div><p><br/>
 <b>Please note that you cannot rely on the implementation detail that the connection is done directly between the processor component and the edit controller.</b></p>
<p><br/>
 Back to <b><a class="el" href="index.html#vst3Contents">Contents</a></b> <br/>
 </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<html>

<head>
	<title>Empty</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<meta name="Author" content="mario">
</head>

<body>

<br/>
<hr width="100%" size="2" align="left" />
<div align=left>
Copyright &copy;2015 <a href="http://www.steinberg.net" target="_blank"><u>Steinberg Media Technologies GmbH</u></a>.
All Rights Reserved.
</div>
</body>

</html>
