<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Base Module: TVector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxysmtg.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSteinberg.html">Steinberg</a>::<a class="el" href="classSteinberg_1_1TVector.html">TVector</a>
  </div>
</div>
<div class="contents">
<h1>TVector&lt; T &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__baseContainer.html">Template Containers</a>]</small>
</h1><!-- doxytag: class="Steinberg::TVector" -->
<p><a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> provides a basic templated container for arrays of dynamic size<a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> is a base class that is not meant to be derived from.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;tvector.h&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a35173dc44fc5e7ed6ff99b776761b7f9">TVector</a> (int32 size=0, const T *items=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor specifying the properties of the <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a>.  <a href="#a35173dc44fc5e7ed6ff99b776761b7f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a752856f0b37a2fae6823420dd1058d26">TVector</a> (int32 size, const T &amp;item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor fills a given number of elements in the vector with copies of a given item.  <a href="#a752856f0b37a2fae6823420dd1058d26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a51518b8ca9836a9622d1267c1793a4c4">TVector</a> (const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor.  <a href="#a51518b8ca9836a9622d1267c1793a4c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a4f6db7027e899293a01b21bf15340cbc">~TVector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ac5a84a83b35447e32ab4cd1378bc8e73">operator=</a> (const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; Destructor. Releases all memory allocated by the vector. The destructor is note declared virtual and thus derivation from <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> is not recommended.  <a href="#ac5a84a83b35447e32ab4cd1378bc8e73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a2cff042faf3fc4f6b976d4ebb7ecf3d8">operator+=</a> (const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append another vector to this vector.  <a href="#a2cff042faf3fc4f6b976d4ebb7ecf3d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a4501211c2e66ae89aebed443df62e530">operator+</a> (const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new vector that appends the contents of another vector to this vector.  <a href="#a4501211c2e66ae89aebed443df62e530"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#adfd19c533c2123be58afcdd1c3caa6a5">operator[]</a> (int32 idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access operator.  <a href="#adfd19c533c2123be58afcdd1c3caa6a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ae76480513eeaa66e4466f2003049e6ca">at</a> (int32 idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a808d0a6e9bc2c9140d55f6682e845f65">operator()</a> (int32 idx, int32 size) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function operator.  <a href="#a808d0a6e9bc2c9140d55f6682e845f65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a52b26969d605e04890755d3cc3ef58b8">array</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; Returns the size of this vector  <a href="#a52b26969d605e04890755d3cc3ef58b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#acbf179c9a4ea046cc4d5388ea85df1bb">assign</a> (const T *items, int32 size=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; Returns a const pointer to the first element stored in this vector. The pointer should not be stored as it will change on insertion and deletion of new elements.  <a href="#acbf179c9a4ea046cc4d5388ea85df1bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ad5476017916a6d386748525fc8b3926d">assign</a> (const T &amp;item, int32 size=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign function that replaces this vector with an arbitrary number of copies of a given element.  <a href="#ad5476017916a6d386748525fc8b3926d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a819e1c510a77bc600f5bef47267044cd">append</a> (const T *items, int32 size=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append function that appends elements stored at the given pointer location to this vector.  <a href="#a819e1c510a77bc600f5bef47267044cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a4fb9da98f38251cb7ab29ab10b5211c8">append</a> (const T &amp;item, int32 size=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append function that appends an arbitrary number of copies of a given element to this vector.  <a href="#a4fb9da98f38251cb7ab29ab10b5211c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a62766d8cdcfd89dc87172417a1a4ff16">insert</a> (int32 idx, const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert function that inserts another vector at a given position of this vector.  <a href="#a62766d8cdcfd89dc87172417a1a4ff16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a536eaddb43ec60f1864ad70295167c7b">insert</a> (int32 idx, const T *items, int32 size=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert function that inserts elements stored at the given pointer location at a given position into this vector.  <a href="#a536eaddb43ec60f1864ad70295167c7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#aea82533c42b39f328c3a1b510f450907">insert</a> (int32 idx, const T &amp;item, int32 size=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert function that inserts an arbitrary number of copies of a given element into a given position in this vector.  <a href="#aea82533c42b39f328c3a1b510f450907"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a9be8c4a7ceb074fef433e28d2152a89a">remove</a> (int32 idx, int32 size=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes items from the vector.  <a href="#a9be8c4a7ceb074fef433e28d2152a89a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a5a3399311490663d6a010689508f2cae">subVector</a> (int32 idx, int32 size) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to extract a subset of the vector.  <a href="#a5a3399311490663d6a010689508f2cae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a722aff9bec64ecb2cfd7ed005fa97b62">resize</a> (int32 size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; Clears the vector and sets the size to 0  <a href="#a722aff9bec64ecb2cfd7ed005fa97b62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a1678ed50ddaed55228e790c7cd534f88">grow</a> (int32 minSize, int32 delta=-1)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class Steinberg::TVector&lt; T &gt;</h3>

<p><a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> provides a basic templated container for arrays of dynamic size</p>
<p><a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> is a base class that is not meant to be derived from. </p>
<p>Elements can be stored and removed from the vector, always causing a resize to the appropriate new size.</p>
<p>Thus, the container always keeps a memory efficient perfect fit. <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> is not suited for high performance insert and removal operations. Consider to use a class with a more sophisticated allocation algorithm if the size of your container is bound to change often.</p>
<p>Insertions and removals on <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> are neither suited for real time processing and are not thread safe because reallocation of memory is neccesary. Random access to elements of the vector is lock free and thread safe.</p>
<p>Because of the TVectors policy to always reallocate new memory, it is not recommended to store pointers or references to the contents of the vector outside of <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a35173dc44fc5e7ed6ff99b776761b7f9"></a><!-- doxytag: member="Steinberg::TVector::TVector" ref="a35173dc44fc5e7ed6ff99b776761b7f9" args="(int32 size=0, const T *items=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>items</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor specifying the properties of the <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>the number of items to be inserted on construction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>items,:</em>&nbsp;</td><td>pointer to the memory were the items are stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a752856f0b37a2fae6823420dd1058d26"></a><!-- doxytag: member="Steinberg::TVector::TVector" ref="a752856f0b37a2fae6823420dd1058d26" args="(int32 size, const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor fills a given number of elements in the vector with copies of a given item. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>the number of copies of the given item to be inserted on construction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item,:</em>&nbsp;</td><td>reference to the item that is to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51518b8ca9836a9622d1267c1793a4c4"></a><!-- doxytag: member="Steinberg::TVector::TVector" ref="a51518b8ca9836a9622d1267c1793a4c4" args="(const TVector&lt; T &gt; &amp;otherVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>otherVector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherVector,:</em>&nbsp;</td><td>the vector that is to be copied on construction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f6db7027e899293a01b21bf15340cbc"></a><!-- doxytag: member="Steinberg::TVector::~TVector" ref="a4f6db7027e899293a01b21bf15340cbc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classSteinberg_1_1TVector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac5a84a83b35447e32ab4cd1378bc8e73"></a><!-- doxytag: member="Steinberg::TVector::operator=" ref="ac5a84a83b35447e32ab4cd1378bc8e73" args="(const TVector&lt; T &gt; &amp;otherVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>otherVector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; Destructor. Releases all memory allocated by the vector. The destructor is note declared virtual and thus derivation from <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> is not recommended. </p>
<p>Assignment operator. <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is...">TVector</a> always reallocated new memory on assignment. Even when both vectors have the same size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherVector,:</em>&nbsp;</td><td>the vector that is to be copied on assignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cff042faf3fc4f6b976d4ebb7ecf3d8"></a><!-- doxytag: member="Steinberg::TVector::operator+=" ref="a2cff042faf3fc4f6b976d4ebb7ecf3d8" args="(const TVector&lt; T &gt; &amp;otherVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>otherVector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append another vector to this vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherVector,:</em>&nbsp;</td><td>The vector that should be appended to this vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4501211c2e66ae89aebed443df62e530"></a><!-- doxytag: member="Steinberg::TVector::operator+" ref="a4501211c2e66ae89aebed443df62e530" args="(const TVector&lt; T &gt; &amp;otherVector) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>otherVector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new vector that appends the contents of another vector to this vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherVector,:</em>&nbsp;</td><td>The vector that should be appended to this vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfd19c533c2123be58afcdd1c3caa6a5"></a><!-- doxytag: member="Steinberg::TVector::operator[]" ref="adfd19c533c2123be58afcdd1c3caa6a5" args="(int32 idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access operator. </p>
<p>Used for read and write access. Note that their is no const counterpart. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx,:</em>&nbsp;</td><td>The index of the element to be accessed. If idx &lt; 0, idx is set to 0. If idx &gt;= (size of this vector), the vector is resized to idx to make access possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae76480513eeaa66e4466f2003049e6ca"></a><!-- doxytag: member="Steinberg::TVector::at" ref="ae76480513eeaa66e4466f2003049e6ca" args="(int32 idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; at </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a808d0a6e9bc2c9140d55f6682e845f65"></a><!-- doxytag: member="Steinberg::TVector::operator()" ref="a808d0a6e9bc2c9140d55f6682e845f65" args="(int32 idx, int32 size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; operator() </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function operator. </p>
<p>Used to extract a subset of the vector. The returned vector is a new vector that contains copies of the elements in the requested subset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx,:</em>&nbsp;</td><td>The index of the first element of the subvector. If idx &lt; 0 or idx &gt;= (size of this vector), an empty vector is returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>Number of elements to be contained in the new vector. If idx + size &gt; (size of this vector), an empty vector is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0de3f5d4514b90b8e820a65bc8aaa0c"></a><!-- doxytag: member="Steinberg::TVector::size" ref="ae0de3f5d4514b90b8e820a65bc8aaa0c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a52b26969d605e04890755d3cc3ef58b8"></a><!-- doxytag: member="Steinberg::TVector::array" ref="a52b26969d605e04890755d3cc3ef58b8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T* array </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; Returns the size of this vector </p>

</div>
</div>
<a class="anchor" id="acbf179c9a4ea046cc4d5388ea85df1bb"></a><!-- doxytag: member="Steinberg::TVector::assign" ref="acbf179c9a4ea046cc4d5388ea85df1bb" args="(const T *items, int32 size=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; assign </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; Returns a const pointer to the first element stored in this vector. The pointer should not be stored as it will change on insertion and deletion of new elements. </p>
<p>Assign function that replaces this vector with the elements stored at the given pointer location. Always allocates new memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>items,:</em>&nbsp;</td><td>pointer to the memory were the items are stored. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>the number of items to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5476017916a6d386748525fc8b3926d"></a><!-- doxytag: member="Steinberg::TVector::assign" ref="ad5476017916a6d386748525fc8b3926d" args="(const T &amp;item, int32 size=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; assign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign function that replaces this vector with an arbitrary number of copies of a given element. </p>
<p>Always allocates new memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item,:</em>&nbsp;</td><td>reference to the item that is to be copied. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>the number of copies of the given item to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a819e1c510a77bc600f5bef47267044cd"></a><!-- doxytag: member="Steinberg::TVector::append" ref="a819e1c510a77bc600f5bef47267044cd" args="(const T *items, int32 size=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; append </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append function that appends elements stored at the given pointer location to this vector. </p>
<p>Always allocates new memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>items,:</em>&nbsp;</td><td>pointer to the memory were the items are stored. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>the number of items to be appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fb9da98f38251cb7ab29ab10b5211c8"></a><!-- doxytag: member="Steinberg::TVector::append" ref="a4fb9da98f38251cb7ab29ab10b5211c8" args="(const T &amp;item, int32 size=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append function that appends an arbitrary number of copies of a given element to this vector. </p>
<p>Always allocates new memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item,:</em>&nbsp;</td><td>reference to the item that is to be copied. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>the number of copies of the given item to bo appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62766d8cdcfd89dc87172417a1a4ff16"></a><!-- doxytag: member="Steinberg::TVector::insert" ref="a62766d8cdcfd89dc87172417a1a4ff16" args="(int32 idx, const TVector&lt; T &gt; &amp;otherVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; insert </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>otherVector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert function that inserts another vector at a given position of this vector. </p>
<p>Always allocates new memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx,:</em>&nbsp;</td><td>index at wich to insert the new vector. If idx = 0, the other vector will be prepended to this vector. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherVector,:</em>&nbsp;</td><td>const reference to the other vector that is to be inserted into this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a536eaddb43ec60f1864ad70295167c7b"></a><!-- doxytag: member="Steinberg::TVector::insert" ref="a536eaddb43ec60f1864ad70295167c7b" args="(int32 idx, const T *items, int32 size=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; insert </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert function that inserts elements stored at the given pointer location at a given position into this vector. </p>
<p>Always allocates new memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx,:</em>&nbsp;</td><td>index at wich to insert the new items. If idx = 0, the other items will be prepended to this vector. If idx &lt; 0 or index &gt; (size of this vector), nothing will be inserted. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>items,:</em>&nbsp;</td><td>pointer to the memory were the items are stored. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>the number of items to be inserted . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea82533c42b39f328c3a1b510f450907"></a><!-- doxytag: member="Steinberg::TVector::insert" ref="aea82533c42b39f328c3a1b510f450907" args="(int32 idx, const T &amp;item, int32 size=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; insert </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert function that inserts an arbitrary number of copies of a given element into a given position in this vector. </p>
<p>Always allocates new memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx,:</em>&nbsp;</td><td>index at wich to insert the new items. If idx = 0, the other items will be prepended to this vector. If idx &lt; 0 or index &gt; (size of this vector), nothing will be inserted. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item,:</em>&nbsp;</td><td>reference to the item that is to be copied. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>the number of copies of the given item to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9be8c4a7ceb074fef433e28d2152a89a"></a><!-- doxytag: member="Steinberg::TVector::remove" ref="a9be8c4a7ceb074fef433e28d2152a89a" args="(int32 idx, int32 size=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; remove </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes items from the vector. </p>
<p>Always allocates new memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx,:</em>&nbsp;</td><td>The index of the first element to be removed from the vector. If idx &lt; 0 idx &gt;= (size of this vector), the vector is returned unchanged. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>Number of elements to be removed from the vector. If idx + size &gt;= (size of this vector), the vector is returned unchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a3399311490663d6a010689508f2cae"></a><!-- doxytag: member="Steinberg::TVector::subVector" ref="a5a3399311490663d6a010689508f2cae" args="(int32 idx, int32 size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; subVector </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to extract a subset of the vector. </p>
<p>The returned vector is a new vector that contains copies of the elements in the requested subset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx,:</em>&nbsp;</td><td>The index of the first element of the subvector. If idx &lt; 0 or idx &gt; (size of this vector), an empty vector is returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>Number of elements to be contained in the new vector. If idx + size &gt; (size of this vector), an empty vector is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a><!-- doxytag: member="Steinberg::TVector::clear" ref="ac8bb3912a3ce86b15842e79d0b421204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a722aff9bec64ecb2cfd7ed005fa97b62"></a><!-- doxytag: member="Steinberg::TVector::resize" ref="a722aff9bec64ecb2cfd7ed005fa97b62" args="(int32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool resize </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; Clears the vector and sets the size to 0 </p>
<p>Resize the whole vector and copies the contained elements to a new location. Always allocates new memory. Even if size == (size of this vector) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size,:</em>&nbsp;</td><td>size of the vector after resize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1678ed50ddaed55228e790c7cd534f88"></a><!-- doxytag: member="Steinberg::TVector::grow" ref="a1678ed50ddaed55228e790c7cd534f88" args="(int32 minSize, int32 delta=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grow </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>minSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>delta</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<html>

<head>
	<title>Empty</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<meta name="Author" content="mario">
</head>

<body>

<br/>
<hr width="100%" size="2" align="left" />
<div align=left>
Copyright &copy;2015 <a href="http://www.steinberg.net" target="_blank"><u>Steinberg Media Technologies GmbH</u></a>.
All Rights Reserved.
</div>
</body>

</html>
