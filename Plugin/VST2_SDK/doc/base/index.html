<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Interface Technology Basics: VST Module Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxysmtg.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>VST Module Architecture </h1><h2><a class="anchor" id="piVstMa">
Introduction</a></h2>
<p><b>VST-MA</b> is a component model system which is used in any <a href="http://www.steinberg.net" target="_blank">Steinberg</a> host application as the basic layer for Plug-in support as well as for internal application components.<br/>
 It is object-oriented, cross-platform and (almost) compiler-independent. <br/>
 The basics are very much like Microsoft(R) COM, so if you are familiar with this technology, understanding VST-MA should be quite easy.</p>
<p><b>VST-MA</b> currently is provided in C++ only. Interfaces in C++ are expressed as pure virtual class (which is a class with nothing but abstract methods). Unlike COM there is no support for C or other languages yet - simply because there has been no need for this so far. But all <b>VST-MA</b> interfaces can be transformed into different representations in case this should be inevitable some day. <br/>
 It is currently available for Windows and Mac OS X.</p>
<p>The C++ files belonging to <b>VST-MA</b> are located in the following folders:</p>
<ul>
<li><a href="../../pluginterfaces/base" target="_blank">pluginterfaces/base</a></li>
<li><a href="../../pluginterfaces/gui" target="_blank">pluginterfaces/gui</a></li>
</ul>
<p><b>Note:</b> The name 'VST Module Architecture' has only little relation to the 'Virtual Studio Technology' itself. <br/>
 It describes the basic layer for any Plug-in category supported in <a href="http://www.steinberg.net" target="_blank">Steinberg</a> hosts. <b>VST-MA</b> has been existing long before it was used as base for VST 3 indeed. The 'VST'-part of the name was introduced only for reasons of misleading advertising... <br/>
 <br/>
</p>
<h2><a class="anchor" id="piInterfaces">
Interfaces</a></h2>
<h3><a class="anchor" id="funknown">
FUnknown</a></h3>
<p><a class="el" href="classSteinberg_1_1FUnknown.html" title="The basic interface of all interfaces.">Steinberg::FUnknown</a> is the basic interface of <b>VST-MA</b>. All other interfaces are directly or indirectly derived from it. <br/>
 <br/>
</p>
<h3><a class="anchor" id="iid">
IID/CID</a></h3>
<p>Each interface has a unique identifier (IID) of type <a class="el" href="classSteinberg_1_1FUID.html" title="Handling 16 Byte Globaly Unique Identifiers.">Steinberg::FUID</a>. It is used to retrieve a new interface from another one (<a class="el" href="classSteinberg_1_1FUnknown.html#ab6c66ef1a65611e850e40e1e1b45b7d5" title="Query for a pointer to the specified interface.">Steinberg::FUnknown::queryInterface</a>). It is important to understand the difference between interface identifier and component identifier.<br/>
 A component-ID or class-ID (CID) is used to identify a concrete implementation class and is usually passed to a class factory in order to create the accordant component. <br/>
 So a lot of different classes (with different class identifiers) can implement the same interfaces. <br/>
 <br/>
</p>
<h3><a class="anchor" id="direction">
Direction</a></h3>
<p>An interface may have a <b>direction</b>, meaning that the interface is expected to be implemented either in the Plug-in or in the host. The nature of an interface is documented like this: <br/>
 <br/>
</p>
<ul>
<li><b>[host imp] </b>: the host implements the interface</li>
<li><b>[plug imp] </b>: the Plug-in implements the interface</li>
</ul>
<p><br/>
 When neither of them is specified, the interface can be used in both ways. <br/>
 <br/>
</p>
<h3><a class="anchor" id="version">
Versioning and inheritance</a></h3>
<p>Unlike C++ classes, interfaces do not use inheritance to express specializations of objects. Inheritance is used for versioning only. One of the strict rules is, that once an interface has been released, it must never change again. Adding new functionality to an interface requires a new version (usually an ordinal number is added to its name in this case).<br/>
 A new version inherits the old version(s) of the interface, so the old and the new methods are combined in one interface. This is why specializations need to be modelled as separate interface! If a specialized interface would inherit from the basic interface as well, an implementation class that needs to implement all these interfaces would inherit the base interface twice and the compiler will start to complain about ambiguities. So the specialization relation to a basic interface can only be expressed in the documentation: <br/>
 <br/>
</p>
<ul>
<li>ISpecialInterface [<b>extends</b> IBaseInterface] =&gt; means IBaseInterface::queryInterface (ISpecialInterface::iid, ...) can be used to retrieve the derived interface.</li>
</ul>
<p><br/>
 You can find some example code here: <a class="el" href="versionInheritance.html">Interface Versions and Inheritance</a> <br/>
 <br/>
</p>
<h3><a class="anchor" id="com">
COM Compatibility</a></h3>
<p>The first layer of <b>VST-MA</b> is binary compatible to <b>COM</b>. The Vtable and Interface Identifier of FUnknown match with the corresponding COM interface IUnknown. The main difference is the organization and creation of components by a host application. <b>VST-MA</b> does not require any Microsoft(R) COM source file. You can find information about <b>COM</b> on pages like: <br/>
</p>
<ul>
<li> <a href="http://www.microsoft.com/Com/resources/comdocs.asp" target="_blank">http://www.microsoft.com/Com/resources/comdocs.asp</a>. <br/>
 <br/>
</li>
</ul>
<h3><a class="anchor" id="basic">
Basic Interfaces</a></h3>
<ul>
<li><a class="el" href="classSteinberg_1_1FUnknown.html" title="The basic interface of all interfaces.">Steinberg::FUnknown</a></li>
<li><a class="el" href="classSteinberg_1_1IPluginBase.html" title="Basic interface to a Plug-in component.">Steinberg::IPluginBase</a></li>
<li><a class="el" href="classSteinberg_1_1IPluginFactory.html" title="Class factory that any Plug-in defines for creating class instances.">Steinberg::IPluginFactory</a> <br/>
 <br/>
</li>
</ul>
<h3><a class="anchor" id="helper">
Helper Classes</a></h3>
<ul>
<li><a class="el" href="classSteinberg_1_1FUID.html" title="Handling 16 Byte Globaly Unique Identifiers.">Steinberg::FUID</a></li>
<li><a class="el" href="classSteinberg_1_1FUnknownPtr.html" title="FUnknownPtr - automatic interface conversion and smart pointer in one.">Steinberg::FUnknownPtr</a></li>
</ul>
<p><br/>
 <br/>
 </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="howtoClass.html">How to derive a class from an interface</a> <br/>
 <br/>
</dd></dl>
<h2><a class="anchor" id="piPlugins">
Plug-ins</a></h2>
<h3><a class="anchor" id="module">
Module Factory:</a></h3>
<p>A module (Windows: Dynamic Link Library, MAC: Mach-O Bundle) contains the implementation of one or more components (e.g. VST Effects). A <b>VST-MA</b> module must contain a class factory where meta-data and create-methods for the components are registered. <br/>
 The host has access to this factory through the <a class="el" href="classSteinberg_1_1IPluginFactory.html" title="Class factory that any Plug-in defines for creating class instances.">Steinberg::IPluginFactory</a> interface. This is the anchor point to the module and it is realized as C-style export function named GetPluginFactory. You can find an export definition file in folder - <a href="../../public.sdk/win/stdplug.def" target="_blank">public.sdk/win/stdplug.def</a> which can be used to export this function. <br/>
 GetPluginFactory is declared as follows:</p>
<div class="fragment"><pre class="fragment">IPluginFactory* PLUGIN_API <a class="code" href="group__pluginBase.html#gae1c930f4bfb3f7b08df00fb107c06091" title="Plug-in entrypoint.">GetPluginFactory</a> ()
</pre></div><p> <br/>
 <br/>
</p>
<h3><a class="anchor" id="Locations">
Locations</a></h3>
<p>Component modules don't require registration like DirectX. The host application expects component modules to be located in predefined folders of the file system. These folders and their subfolders are scanned at application startup for <b>VST-MA</b> modules. Each folder serves a special purpose:</p>
<ul>
<li>The application's <code>Components</code> subfolder (e.g. "C:\Program Files\Steinberg\Cubase SX\Components") is used for components tightly bound to the application. No other application should use it.</li>
<li>Components that are shared between all <a href="http://www.steinberg.net" target="_blank">Steinberg</a> hosts are located at:<ul>
<li>Win: "/Program Files/Common Files/Steinberg/shared components"</li>
<li>Mac: "/Library/Application Support/Steinberg/Components/"</li>
</ul>
</li>
<li>For special purpose Plug-in types, additional locations can be defined. Please refer to the corresponding documentation to find out if additional folders are used and where they are. <br/>
 <br/>
</li>
</ul>
<h3><a class="anchor" id="Categories">
Categories</a></h3>
<p>Any class that the factory can create is assigned to a category. It is this category that tells the host the purpose of the class (and gives a hint of wich interfaces it might implement). <br/>
 A class is also described with a name and it has a unique id.</p>
<ul>
<li>The category for import/export filters is <b>"Project Filter"</b> and for VST 3 Audio Plug-ins <b>"Audio Module Class"</b> for example.</li>
<li>A special category is "Service". The purpose of a class of this category is completely unknown to the host. It will be loaded automatically at the program start (if the user did not deactivate it).</li>
<li>Since the factory can create any number of classes, one component library can contain multiple components of any type. <br/>
 <br/>
</li>
</ul>
<h3><a class="anchor" id="IPluginBase">
IPluginBase</a></h3>
<p>The entry-point interface for any component class is <a class="el" href="classSteinberg_1_1IPluginBase.html" title="Basic interface to a Plug-in component.">Steinberg::IPluginBase</a>. The host uses this interface to initialize and to terminate the Plug-in component. When the host initializes the Plug-in, it passes a so called context. This context contains any interface to the host that the Plug-in will need to work. <br/>
 <br/>
</p>
<h3><a class="anchor" id="purpose">
Purpose-specific interfaces</a></h3>
<p>Each Plug-in category (VST 3 Effects, Project import/export Filters, Audio Codecs, etc...) defines its own set of purpose-specific interfaces. These are not part of the basic VST-MA layer. <br/>
 <br/>
 </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="loadPlugin.html">How the host will load a Plug-in</a> <br/>
 <br/>
</dd></dl>
<h2><a class="anchor" id="Unicode">
Unicode</a></h2>
<p>Beginning with version 5 of Cubase and Nuendo, the internal structure of the host was modified to better support internationalization. Therefore the string handling was changed to utilize <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a> strings whenever strings are passed around. Consequently all the interfaces to Plug-ins have changed from using ASCI to Unicode strings as call and return parameters as well. So in turn also any Plug-in has to be adapted to support Unicode. This has major consequences in that:</p>
<ul>
<li>Unicode hosts (Cubase5 or later) will only work with Unicode Plug-ins. While loading a Plug-in a Unicode host will check the Plug-in's type and refuse to load any Plug-in that is non-Unicode. <br/>
</li>
<li>Unicode Plug-ins will <b>not</b> load into non-Unicode hosts. While loading a Unicode Plug-in will request information from the host and refuse to load itself, if no Unicode host is detected. Therefore, if a Plug-in is supposed to work on both older and newer hosts, it is best to provide two versions of the Plug-in. <br/>
 <br/>
</li>
</ul>
<h3><a class="anchor" id="plugunicode">
Plug-ins for only Unicode hosts</a></h3>
<p>Writing Plug-ins that are supposed to work only on Unicode hosts is easy. Use a current version of this SDK and develop a Plug-in as usual. Make sure that you only ever pass Unicode <a href="http://en.wikipedia.org/wiki/UTF-16">UTF16</a> strings to interfaces that have strings as call parameters and also be prepared that interface return strings are always <a href="http://en.wikipedia.org/wiki/UTF-16">UTF16</a>. Therefore, to make things easier, it is recommended that throughout the Plug-in's implementation Unicode strings are used, in order to avoid back and forth conversions. To make things even more easy, use the Steinberg::String and Steinberg::ConstString classes from the Base module, they have been designed to work universially on both, Mac and Win. <br/>
 <br/>
</p>
<h3><a class="anchor" id="migrating">
Migrating from non-Unicode to Unicode</a></h3>
<p>In <a href="http://www.steinberg.net" target="_blank">Steinberg</a> SDKs released before Cubase5 the interface functions were using pointers of type <code> char </code> for passing strings to and from the host. These have been changed now to using Steinberg's defined type <code> tchar </code> which is equivalent to <code> char16 </code>, i.e. 16 bit character. There are theoretically many ways of how characters could be represented in 16 bits, but we chose to use the industry standard <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a>, so strings are expected to be encoded in <a href="http://en.wikipedia.org/wiki/UTF-16">UTF16</a>. <br/>
 Accordingly also the implementation of a Plug-in needs to be adapted to deal correctly with Unicode encoded strings, as well as only ever passing Unicode strings to the host. <br/>
 <br/>
 <b>Technical note</b>: Changing a function from using 8 bit to 16 bit character pointers seems to be only a minor modification, but in interface design this is a major intrusion, because an interface is a contract to the outer world that is never to be changed. Therefore, classes that were changed to use Unicode strings are distinguished and also received a new unique class id. <br/>
 <br/>
</p>
<h3><a class="anchor" id="backward">
SDK backward compatibility</a></h3>
<p>Even with the current SDK it is still possible to develop non-Unicode Plug-ins. In the file <a href="../../pluginterfaces/base/ftypes.h">pluginterfaces/base/ftypes.h</a> the line "#define UNICODE_OFF" is commented out, but if it gets uncommented, then all interfaces will revert back to using single byte ASCI strings. Alternatively you could also specify UNICODE_OFF as preprocessor definition in your project file.<br/>
 Also the Plug-in's factory info will then not define the Unicode flag anymore, so a Unicode host will see the compiled Plug-in as non-Unicode. As a matter of course, when reverting back to single byte strings the Plug-in's implementation also has to be changed to behave correctly. <br/>
 <br/>
 <b>Technical note</b>: When undefining Unicode also the class ids will revert back to the old ones. <br/>
 <br/>
 </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<html>

<head>
	<title>Empty</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<meta name="Author" content="mario">
</head>

<body>

<br/>
<hr width="100%" size="2" align="left" />
<div align=left>
Copyright &copy;2015 <a href="http://www.steinberg.net" target="_blank"><u>Steinberg Media Technologies GmbH</u></a>.
All Rights Reserved.
</div>
</body>

</html>
